pub use discord_sdk as ds;

pub const APP_ID: ds::AppId = 310270644849737729;

struct Printer(tokio::sync::mpsc::Sender<Option<ds::user::User>>);

#[async_trait::async_trait]
impl ds::DiscordHandler for Printer {
    async fn on_event(&self, event: ds::Event) {
        println!("received event form discord: {:#?}", event);

        match event {
            ds::Event::Ready { user, .. } => {
                self.0.send(Some(user)).await.unwrap();
            }
            ds::Event::Disconnected { .. } => {
                self.0.send(None).await.unwrap();
            }
            _ => {}
        }
    }

    async fn on_error(&self, error: ds::Error) {
        eprintln!("an error occurred! {:#?}", error);
    }
}

pub async fn make_client(subs: ds::Subscriptions) -> (ds::Discord, ds::user::User) {
    let (tx, mut rx) = tokio::sync::mpsc::channel(1);

    tracing_subscriber::fmt()
        .compact()
        .with_max_level(tracing::Level::TRACE)
        .init();

    let discord = ds::Discord::new(ds::DiscordApp::PlainId(APP_ID), subs, Box::new(Printer(tx)))
        .expect("unable to create discord client");

    tracing::info!("waiting for handshake...");
    let user = rx
        .recv()
        .await
        .unwrap()
        .expect("user should have been sent after handshake");

    (discord, user)
}
